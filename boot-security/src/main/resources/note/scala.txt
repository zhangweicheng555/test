



C:\Users\dell>scala
Welcome to Scala version 2.10.4 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_171).
Type in expressions to have them evaluated.
Type :help for more information.

scala> val i=1
i: Int = 1

scala> val i=2;
i: Int = 2

scala> i =10
<console>:8: error: reassignment to val
       i =10
         ^

scala> val zwc=2
zwc: Int = 2

scala> zwc=4
<console>:8: error: reassignment to val
       zwc=4
          ^

scala> var zzz=2
zzz: Int = 2

scala> zzz=4
zzz: Int = 4

scala> val zwp : String ="zwc";
zwp: String = zwc

scala> zwp
res0: String = zwc

scala> val e : Int=100;
e: Int = 100

scala> e
res1: Int = 100

scala> val s=if(e>0) 1 else -1
s: Int = 1

scala> e
res2: Int = 100

scala> val zwa=if(e>1110) 1 else "zwc"
zwa: Any = zwc

scala> zwa
res3: Any = zwc

scala> e
res4: Int = 100

scala> val k=if(e<0) -1 else if(e>0 && e<100) 1 else 2;
k: Int = 2

scala> print e
<console>:8: error: missing arguments for method print in object Predef;
follow this method with `_' if you want to treat it as a partially applied function
              print e
              ^

scala> print(e);
100
scala> println(e);
100

scala> 1 to 10\
<console>:8: error: value \ is not a member of scala.collection.immutable.Range.Inclusive
              1 to 10\
                     ^

scala> 1 to 10
res9: scala.collection.immutable.Range.Inclusive = Range(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

scala> for(k <- 1 to 10){println(k);}
1
2
3
4
5
6
7
8
9
10

scala> for(m <- 1to 10){m}
<console>:1: error: Invalid literal number
       for(m <- 1to 10){m}
                ^

scala> for(m <- 1to 10){println(m);}
<console>:1: error: Invalid literal number
       for(m <- 1to 10){println(m);}
                ^

scala> for(m <- 1 to 10){println(m);}
1
2
3
4
5
6

scala> var zsd=for(i <- 1 to 10) yield i*10 println(i)
<console>:8: error: value println is not a member of Int
       var zsd=for(i <- 1 to 10) yield i*10 println(i)
                                            ^

scala> var zsd=for(i <- 1 to 10) yield i*10
zsd: scala.collection.immutable.IndexedSeq[Int] = Vector(10, 20, 30, 40, 50, 60, 70, 80, 90, 100)

scala> zsd
res14: scala.collection.immutable.IndexedSeq[Int] = Vector(10, 20, 30, 40, 50, 60, 70, 80, 90, 100)

scala> var df=for(m <- 1 to 10) yield m -1;
df: scala.collection.immutable.IndexedSeq[Int] = Vector(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)

scala> df
res15: scala.collection.immutable.IndexedSeq[Int] = Vector(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)

scala> df
res16: scala.collection.immutable.IndexedSeq[Int] = Vector(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)

scala> 1.to(11).map(_+100)
res17: scala.collection.immutable.IndexedSeq[Int] = Vector(101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111)

scala> 1.to(11).map(_+100)
res18: scala.collection.immutable.IndexedSeq[Int] = Vector(101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111)

scala> arr
res19: Array[Int] = Array(1, 2, 3, 4)

scala> var dfg=for(i <-arr;if(i>3)) yield i*100
dfg: Array[Int] = Array(400)

scala> arr
res20: Array[Int] = Array(1, 2, 3, 4)

scala> arr.filter(_ > 2)
res21: Array[Int] = Array(3, 4)

scala> arr.filter(_ > 2).map(_*2)
res22: Array[Int] = Array(6, 8)

scala>

scala> 0 until  arr.length
res25: scala.collection.immutable.Range = Range(0, 1, 2, 3)

scala> for(i <- 0 until arr.length) arr(i)

scala> for(i <- 0 until arr.length)  println(arr(i))

scala> def m1(x: Int,y: Int): Int =x+y
m1: (x: Int, y: Int)Int

scala> var t=m1(2,3)
t: Int = 5



scala> var fr=(x: Int) => x* 10
fr: Int => Int = <function1>

scala> var ft=(x: Int) => x+10
ft: Int => Int = <function1>

scala> arr
res42: scala.collection.immutable.Range.Inclusive = Range(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

scala> arr.map(fr)
res43: scala.collection.immutable.IndexedSeq[Int] = Vector(10, 20, 30, 40, 50, 60, 70, 80, 90, 100)

scala> arr.map(fr(_))
res44: scala.collection.immutable.IndexedSeq[Int] = Vector(10, 20, 30, 40, 50, 60, 70, 80, 90, 100)

scala> arr.map(ft(_))
res45: scala.collection.immutable.IndexedSeq[Int] = Vector(11, 12, 13, 14, 15, 16, 17, 18, 19, 20)

scala>


scala> arr.map(x => x*10)
res47: scala.collection.immutable.IndexedSeq[Int] = Vector(10, 20, 30, 40, 50, 60, 70, 80, 90, 100)

             ^

scala> arr.map(_ * 10)
res49: scala.collection.immutable.IndexedSeq[Int] = Vector(10, 20, 30, 40, 50, 60, 70, 80, 90, 100)
                  ^

scala> arr.map((x: Int) => x*10)
res51: scala.collection.immutable.IndexedSeq[Int] = Vector(10, 20, 30, 40, 50, 60, 70, 80, 90, 100)




object HelloScala {
  
    def method_1(fun: Int => Int): Int ={
      fun(3)
    }
    

    val fun1=(x: Int) => x*10
    
    def main(args : Array[String]){
       println(method_1(fun1))
    }
 
}







object HelloScala {
  
    def method_1(fun: Int => Int): Int ={
      fun(3)
    }
    
    def method_2(fun:(Int,Int) => Int) ={
      fun(3,4)
    }
    
    val fun1=(x: Int) => x*10

  val fun2 = (x: Int, y: Int) => x + y
    
    def main(args : Array[String]){
       println(method_1(fun1))
       
       println(method_2(fun2))
    }
  
}




 def main(args: Array[String]) {

    def f1(x: Int, y: Int): Int = x + y
    var fun3 = (x: Int, y: Int) => x + y

    val fun1: Int => Int = { x => x + 5 }
    val fun2: (Int, Int) => Int = { (x, y) => x * y }
    println(fun1(3)) //8
    println(fun2(8, 3)) //24
    println(f1(8, 3)) //11
    println(fun3(8, 3)) //11
  }



def method_0(x Int,y Int): Int =x+y
val fun2(Int,Int) => Int={(x,y) => x+y}



 def main(args: Array[String]) {

    var arr = Array(1, 2, 3, 4, 5, 6, 7)
    var a1 = arr.map((x: Int) => x * 10)
    var a2 = arr.map(x => x + 5)
    println(a1.toBuffer)
    println(a2.toBuffer)

  }


val fun1=(x: Int,y: Int) => (y,x)
fun1: (Int, Int) => (Int, Int) = <function2>

scala> fun1(9,0)
res3: (Int, Int) = (0,9)



 val fun2:(Int,Int) =>(Int,Int) ={(x,y) => (y,x)}
fun2: (Int, Int) => (Int, Int) = <function2>



神奇的下划线


将方法直接变成了函数
scala> def mm(x: Int,y: Int): Int ={x+y}
mm: (x: Int, y: Int)Int

scala> mm(8.9)
<console>:9: error: not enough arguments for method mm: (x: Int, y: Int)Int.
Unspecified value parameter y.
              mm(8.9)
                ^

scala> mm(8,9)
res8: Int = 17

scala> val zd=mm _
zd: (Int, Int) => Int = <function2>

scala> zd
res9: (Int, Int) => Int = <function2>

scala> zd(8,9)
res10: Int = 17




scala> val arr1=new Array[Int](10)
arr1: Array[Int] = Array(0, 0, 0, 0, 0, 0, 0, 0, 0, 0)

scala> arr1(1)=1

scala> arr1
res12: Array[Int] = Array(0, 1, 0, 0, 0, 0, 0, 0, 0, 0)

scala> val arr2=Array(1,2,3)
arr2: Array[Int] = Array(1, 2, 3)




 //变长数组（数组缓冲）  一下注意
    //如果想使用数组缓冲，需要导入import scala.collection.mutable.ArrayBuffer包
    val ab = ArrayBuffer[Int]()
    //向数组缓冲的尾部追加一个元素
    //+=尾部追加元素
    ab += 1
    //追加多个元素
    ab += (2, 3, 4, 5)
    //追加一个数组++=
    ab ++= Array(6, 7)
    //追加一个数组缓冲
    ab ++= ArrayBuffer(8,9)
    //打印数组缓冲ab

    //在数组某个位置插入元素用insert
    ab.insert(0, -1, 0)
    //删除数组某个位置的元素用remove
    ab.remove(8, 2)



1.增强for循环
2.好用的until会生成脚标，0 until 10 包含0不包含10

val arr = Array(1,2,3,4,5,6,7,8)
    //增强for循环
    for(i <- arr)
      println(i)

    //好用的until会生成一个Range
    //reverse是将前面生成的Range反转
    for(i <- (0 until arr.length).reverse)
      println(arr(i))



yield关键字将原始的数组进行转换会产生一个新的数组，原始的数组不变

//定义一个数组
    val arr = Array(1, 2, 3, 4, 5, 6, 7, 8, 9)
    //将偶数取出乘以10后再生成一个新的数组
    val res = for (e <- arr if e % 2 == 0) yield e * 10
    println(res.toBuffer)

    //更高级的写法,用着更爽
    //filter是过滤，接收一个返回值为boolean的函数
    //map相当于将数组中的每一个元素取出来，应用传进去的函数
    val r = arr.filter(_ % 2 == 0).map(_ * 10)
    println(r.toBuffer)



5.1.4.数组常用算法

scala> arr1
res19: Array[Int] = Array(0, 1, 0, 0, 0, 0, 0, 0, 0, 0)

scala> arr1.max
res20: Int = 1

scala> arr1.sorted
res21: Array[Int] = Array(0, 0, 0, 0, 0, 0, 0, 0, 0, 1)

scala> arr1.sum
res22: Int = 1

scala> arr1.
apply          asInstanceOf   clone          isInstanceOf   length         toString       update

scala> arr1.\

