



C:\Users\dell>scala
Welcome to Scala version 2.10.4 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_171).
Type in expressions to have them evaluated.
Type :help for more information.

scala> val i=1
i: Int = 1

scala> val i=2;
i: Int = 2

scala> i =10
<console>:8: error: reassignment to val
       i =10
         ^

scala> val zwc=2
zwc: Int = 2

scala> zwc=4
<console>:8: error: reassignment to val
       zwc=4
          ^

scala> var zzz=2
zzz: Int = 2

scala> zzz=4
zzz: Int = 4

scala> val zwp : String ="zwc";
zwp: String = zwc

scala> zwp
res0: String = zwc

scala> val e : Int=100;
e: Int = 100

scala> e
res1: Int = 100

scala> val s=if(e>0) 1 else -1
s: Int = 1

scala> e
res2: Int = 100

scala> val zwa=if(e>1110) 1 else "zwc"
zwa: Any = zwc

scala> zwa
res3: Any = zwc

scala> e
res4: Int = 100

scala> val k=if(e<0) -1 else if(e>0 && e<100) 1 else 2;
k: Int = 2

scala> print e
<console>:8: error: missing arguments for method print in object Predef;
follow this method with `_' if you want to treat it as a partially applied function
              print e
              ^

scala> print(e);
100
scala> println(e);
100

scala> 1 to 10\
<console>:8: error: value \ is not a member of scala.collection.immutable.Range.Inclusive
              1 to 10\
                     ^

scala> 1 to 10
res9: scala.collection.immutable.Range.Inclusive = Range(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

scala> for(k <- 1 to 10){println(k);}
1
2
3
4
5
6
7
8
9
10

scala> for(m <- 1to 10){m}
<console>:1: error: Invalid literal number
       for(m <- 1to 10){m}
                ^

scala> for(m <- 1to 10){println(m);}
<console>:1: error: Invalid literal number
       for(m <- 1to 10){println(m);}
                ^

scala> for(m <- 1 to 10){println(m);}
1
2
3
4
5
6

scala> var zsd=for(i <- 1 to 10) yield i*10 println(i)
<console>:8: error: value println is not a member of Int
       var zsd=for(i <- 1 to 10) yield i*10 println(i)
                                            ^

scala> var zsd=for(i <- 1 to 10) yield i*10
zsd: scala.collection.immutable.IndexedSeq[Int] = Vector(10, 20, 30, 40, 50, 60, 70, 80, 90, 100)

scala> zsd
res14: scala.collection.immutable.IndexedSeq[Int] = Vector(10, 20, 30, 40, 50, 60, 70, 80, 90, 100)

scala> var df=for(m <- 1 to 10) yield m -1;
df: scala.collection.immutable.IndexedSeq[Int] = Vector(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)

scala> df
res15: scala.collection.immutable.IndexedSeq[Int] = Vector(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)

scala> df
res16: scala.collection.immutable.IndexedSeq[Int] = Vector(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)

scala> 1.to(11).map(_+100)
res17: scala.collection.immutable.IndexedSeq[Int] = Vector(101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111)

scala> 1.to(11).map(_+100)
res18: scala.collection.immutable.IndexedSeq[Int] = Vector(101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111)

scala> arr
res19: Array[Int] = Array(1, 2, 3, 4)

scala> var dfg=for(i <-arr;if(i>3)) yield i*100
dfg: Array[Int] = Array(400)

scala> for(i <- cloo;if(i>3);if(i <= 6)) println(i)
4
5
6


scala> cloo
res22: scala.collection.immutable.Range.Inclusive = Range(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

scala> cloo.filter(_>3).filter(_<=6)
res23: scala.collection.immutable.IndexedSeq[Int] = Vector(4, 5, 6)

scala> cloo.filter(_>3).filter(_<=6).map(_*10)
res24: scala.collection.immutable.IndexedSeq[Int] = Vector(40, 50, 60)

scala> cloo.filter(_>3 && _<=6)
<console>:9: error: wrong number of parameters; expected = 1
              cloo.filter(_>3 && _<=6)

scala> arr
res20: Array[Int] = Array(1, 2, 3, 4)

scala> arr.filter(_ > 2)
res21: Array[Int] = Array(3, 4)

scala> arr.filter(_ > 2).map(_*2)
res22: Array[Int] = Array(6, 8)

scala>

scala> 0 until  arr.length
res25: scala.collection.immutable.Range = Range(0, 1, 2, 3)

scala> for(i <- 0 until arr.length) arr(i)

scala> for(i <- 0 until arr.length)  println(arr(i))

scala> def m1(x: Int,y: Int): Int =x+y
m1: (x: Int, y: Int)Int

scala> var t=m1(2,3)
t: Int = 5



scala> var fr=(x: Int) => x* 10
fr: Int => Int = <function1>

scala> var ft=(x: Int) => x+10
ft: Int => Int = <function1>

scala> arr
res42: scala.collection.immutable.Range.Inclusive = Range(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

scala> arr.map(fr)
res43: scala.collection.immutable.IndexedSeq[Int] = Vector(10, 20, 30, 40, 50, 60, 70, 80, 90, 100)

scala> arr.map(fr(_))
res44: scala.collection.immutable.IndexedSeq[Int] = Vector(10, 20, 30, 40, 50, 60, 70, 80, 90, 100)

scala> arr.map(ft(_))
res45: scala.collection.immutable.IndexedSeq[Int] = Vector(11, 12, 13, 14, 15, 16, 17, 18, 19, 20)

scala>


scala> arr.map(x => x*10)
res47: scala.collection.immutable.IndexedSeq[Int] = Vector(10, 20, 30, 40, 50, 60, 70, 80, 90, 100)

             ^

scala> arr.map(_ * 10)
res49: scala.collection.immutable.IndexedSeq[Int] = Vector(10, 20, 30, 40, 50, 60, 70, 80, 90, 100)
                  ^

scala> arr.map((x: Int) => x*10)
res51: scala.collection.immutable.IndexedSeq[Int] = Vector(10, 20, 30, 40, 50, 60, 70, 80, 90, 100)




object HelloScala {
  
    def method_1(fun: Int => Int): Int ={
      fun(3)
    }
    

    val fun1=(x: Int) => x*10
    
    def main(args : Array[String]){
       println(method_1(fun1))
    }
 
}







object HelloScala {
  
    def method_1(fun: Int => Int): Int ={
      fun(3)
    }
    
    def method_2(fun:(Int,Int) => Int) ={
      fun(3,4)
    }
    
    val fun1=(x: Int) => x*10

  val fun2 = (x: Int, y: Int) => x + y
    
    def main(args : Array[String]){
       println(method_1(fun1))
       
       println(method_2(fun2))
    }
  
}




 def main(args: Array[String]) {

    def f1(x: Int, y: Int): Int = x + y
    var fun3 = (x: Int, y: Int) => x + y

    val fun1: Int => Int = { x => x + 5 }
    val fun2: (Int, Int) => Int = { (x, y) => x * y }
    println(fun1(3)) //8
    println(fun2(8, 3)) //24
    println(f1(8, 3)) //11
    println(fun3(8, 3)) //11
  }



scala> var fg:(Int,Int) => Int ={(x,y)=>x+y}
fg: (Int, Int) => Int = <function2>

scala> def mmg(fun:(Int,Int) => Int): Int={fun(7,8)}
mmg: (fun: (Int, Int) => Int)Int

scala> var w=mmg(fg)
w: Int = 15

scala> w
res48: Int = 15

scala>



def method_0(x Int,y Int): Int =x+y
val fun2(Int,Int) => Int={(x,y) => x+y}



 def main(args: Array[String]) {

    var arr = Array(1, 2, 3, 4, 5, 6, 7)
    var a1 = arr.map((x: Int) => x * 10)
    var a2 = arr.map(x => x + 5)
    println(a1.toBuffer)
    println(a2.toBuffer)

  }


val fun1=(x: Int,y: Int) => (y,x)
fun1: (Int, Int) => (Int, Int) = <function2>

scala> fun1(9,0)
res3: (Int, Int) = (0,9)



 val fun2:(Int,Int) =>(Int,Int) ={(x,y) => (y,x)}
fun2: (Int, Int) => (Int, Int) = <function2>



神奇的下划线


将方法直接变成了函数
scala> def mm(x: Int,y: Int): Int ={x+y}
mm: (x: Int, y: Int)Int

scala> mm(8.9)
<console>:9: error: not enough arguments for method mm: (x: Int, y: Int)Int.
Unspecified value parameter y.
              mm(8.9)
                ^

scala> mm(8,9)
res8: Int = 17

scala> val zd=mm _
zd: (Int, Int) => Int = <function2>

scala> zd
res9: (Int, Int) => Int = <function2>

scala> zd(8,9)
res10: Int = 17




scala> val arr1=new Array[Int](10)
arr1: Array[Int] = Array(0, 0, 0, 0, 0, 0, 0, 0, 0, 0)

scala> arr1(1)=1

scala> arr1
res12: Array[Int] = Array(0, 1, 0, 0, 0, 0, 0, 0, 0, 0)

scala> val arr2=Array(1,2,3)
arr2: Array[Int] = Array(1, 2, 3)




 //变长数组（数组缓冲）  一下注意
    //如果想使用数组缓冲，需要导入import scala.collection.mutable.ArrayBuffer包
    val ab = ArrayBuffer[Int]()
    //向数组缓冲的尾部追加一个元素
    //+=尾部追加元素
    ab += 1
    //追加多个元素
    ab += (2, 3, 4, 5)
    //追加一个数组++=
    ab ++= Array(6, 7)
    //追加一个数组缓冲
    ab ++= ArrayBuffer(8,9)
    //打印数组缓冲ab

    //在数组某个位置插入元素用insert  第0个位置插入一个或者多个
    ab.insert(0, -1, 0)    
    //删除数组某个位置的元素用remove
    ab.remove(8, 2)



1.增强for循环
2.好用的until会生成脚标，0 until 10 包含0不包含10

val arr = Array(1,2,3,4,5,6,7,8)
    //增强for循环
    for(i <- arr)
      println(i)

    //好用的until会生成一个Range
    //reverse是将前面生成的Range反转
    for(i <- (0 until arr.length).reverse)
      println(arr(i))



yield关键字将原始的数组进行转换会产生一个新的数组，原始的数组不变

//定义一个数组
    val arr = Array(1, 2, 3, 4, 5, 6, 7, 8, 9)
    //将偶数取出乘以10后再生成一个新的数组
    val res = for (e <- arr if e % 2 == 0) yield e * 10
    println(res.toBuffer)

    //更高级的写法,用着更爽
    //filter是过滤，接收一个返回值为boolean的函数
    //map相当于将数组中的每一个元素取出来，应用传进去的函数
    val r = arr.filter(_ % 2 == 0).map(_ * 10)
    println(r.toBuffer)



5.1.4.数组常用算法

scala> arr1
res19: Array[Int] = Array(0, 1, 0, 0, 0, 0, 0, 0, 0, 0)

scala> arr1.max
res20: Int = 1

scala> arr1.sorted
res21: Array[Int] = Array(0, 0, 0, 0, 0, 0, 0, 0, 0, 1)

scala> arr1.sum
res22: Int = 1

scala> arr1.
apply          asInstanceOf   clone          isInstanceOf   length         toString       update

scala> arr1.\











Byte	8位有符号补码整数。数值区间为 -128 到 127
Short	16位有符号补码整数。数值区间为 -32768 到 32767
Int	32位有符号补码整数。数值区间为 -2147483648 到 2147483647
Long	64位有符号补码整数。数值区间为 -9223372036854775808 到 9223372036854775807
Float	32 位, IEEE 754标准的单精度浮点数
Double	32 位 IEEE 754标准的单精度浮点数
Char	16位无符号Unicode字符, 区间值为 U+0000 到 U+FFFF
String	字符序列
Boolean	true或false
Unit	表示无值，和其他语言中void等同。用作不返回任何结果的方法的结果类型。Unit只有一个实例值，写成()。
Null	null 或空引用
Nothing	Nothing类型在Scala的类层级的最低端；它是任何其他类型的子类型。
Any	Any是所有其他类的超类
AnyRef	AnyRef类是Scala里所有引用类(reference class)的基类



      
scala> var a2=Array("zwp","sdw","sdf","gft","asd")
a2: Array[String] = Array(zwp, sdw, sdf, gft, asd)

scala> a2
res124: Array[String] = Array(zwp, sdw, sdf, gft, asd)

scala> a2.reverse
res125: Array[String] = Array(asd, gft, sdf, sdw, zwp)

scala> a2.sortBy(x => x)
res126: Array[String] = Array(asd, gft, sdf, sdw, zwp)

scala> a2
res127: Array[String] = Array(zwp, sdw, sdf, gft, asd)

scala> a2.sortWith((x,y) => x>y)
res128: Array[String] = Array(zwp, sdw, sdf, gft, asd)

scala> a2.sortWith((x,y) => x<y)
res129: Array[String] = Array(asd, gft, sdf, sdw, zwp)

scala> a2.sortWith(_>_)
res130: Array[String] = Array(zwp, sdw, sdf, gft, asd)

scala> a2.sortWith(_<_)
res131: Array[String] = Array(asd, gft, sdf, sdw, zwp)




构建一个不可变映射
val scores = Map("Alice"->10,"Bob"->3,"Cindy"->8)


构建一个可变映射
val scores = scala.collection.mutable.Map("Alice"->10,"Bob"->3,"Cindy"->8)

构建一个空映射
val scores = new scala.collection.mutable.HashMap[String,Int]

也可以用下面的方式创建映射
val scores = Map(("Alice",10),("Bob",3),("Cindy",8))

获取映射中的值
val bobsScore = scores("Bob")

如果映射不包含请求中使用的键则会抛出异常
val bobsScore = if(scores.contains("Bob"))scores("Bob") else 0
val bobsScore = scores.getOrElse("Bob",0)

更新映射中的值
可变映射可以更新某个映射的值，或者添加一个新的映射关系
scores("Bob") = 10 //更新
scores("Fred") = 7 //增加新的键值对
scores += ("Bob"->10,"Fred"->7)//用+=操作来添加多个关系
scores -= "Alice" //移除某个键和对应的值

对于不可变映射，可以获取一个包含所需的变更的新映射：
var newScores = scores + ("Bob"->10,"Fred"->7)
newScores = newScores - "Bob"

迭代映射
for((k,v) <- 映射) 处理k和v
for(k <- scores.keySet) print(k)
for(v <= scores.values) print(v)
for((k,v) <- scores) yield (v,k) //反转映射

排序映射
val scores = scala.collection.immutable.SortedMap("Alice"->10,"Bob"->3,"Cindy"->8)

按插入的顺序访问所以的键
val months = scala.collection.mutable.LinkedHashMap("January"->1,"February"->2)

